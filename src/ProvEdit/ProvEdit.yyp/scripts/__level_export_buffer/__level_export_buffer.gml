function __level_export_buffer() {
	var b = buffer_create(1024, buffer_grow, 1);
	var _left = abs(lv_left) >> 4
	var _top = abs(lv_top) >> 4

	stringbuffer_write(b, "-- Generated by ProvEdit version " + editor_version + " --\n")

#region level info
		stringbuffer_write(b, "local STAGE_INFO = {\n")
		stringbuffer_write(b, "    name = \""	+ global.level_name					+ "\",\n")
		stringbuffer_write(b, "    subname = \""	+ global.level_subname				+ "\",\n")
		stringbuffer_write(b, "    width = "		+ string(abs(lv_left) + lv_right)	+ ",\n")
		stringbuffer_write(b, "    height = "	+ string(abs(lv_top) + lv_bottom)	+ ",\n")
		// TODO: this should probably be a separate name (PROVEDIT_MUSIC.rorInternalName or smth)
		stringbuffer_write(b, "    music = \""		+
			global.ProvEdit_music[global.level_music, PROVEDIT_MUSIC.internalName]	+ "\"\n")
		stringbuffer_write(b, "}\n")
		stringbuffer_write(b, "\n")
#endregion

#region layers
		stringbuffer_write(b, "local STAGE_LAYERS = {\n")
		for (var i = 0; i < array_length_1d(global.tiles); i++) {
			stringbuffer_write(b, "    {\n")
			var l = global.tiles[i]
		
			stringbuffer_write(b, "        depth = " + string(l.depth) + ",\n")
			// TODO: this should probably be a separate name (PROVEDIT_TILESET.rorInternalName or smth)
			stringbuffer_write(b, "        sprite = \""
				+ global.ProvEdit_tileset[l.tileset, PROVEDIT_TILESET.resName] + "\",\n")
			stringbuffer_write(b, "        origin = \""
				+ global.ProvEdit_tileset[l.tileset, PROVEDIT_TILESET.modName] + "\",\n")
			if (global.ProvEdit_tileset[l.tileset, PROVEDIT_TILESET.hasGrid]) {
				stringbuffer_write(b, "        grid = true,\n")
			}

		#region tiles
				stringbuffer_write(b, "        tiles = {\n")
				var tile_data = l.tile_data
				var s = ds_map_size(tile_data)
				var key = ds_map_find_first(tile_data)
				repeat (s) {
					stringbuffer_write(b, "            [" + string(_left + key) + "] = {\n")
					stringbuffer_write(b, "                ")
					var tile_data2 = tile_data[? key]
					var s2 = ds_map_size(tile_data2)
					var key2 = ds_map_find_first(tile_data2)
					var tile_count = 0
					repeat (s2) {
						if (tile_count >= 20) {
							stringbuffer_write(b, "\n                ")
							tile_count = 0
						}
						var tile = tile_data2[? key2]
						stringbuffer_write(b, "[" + string(_top + key2) + "] = {"
							+ string(tile_get_img_x(tile)) + ","
							+ string(tile_get_img_y(tile)) + "}, ")
						tile_count++
						key2 = ds_map_find_next(tile_data2, key2)
					}
					stringbuffer_write(b, "\n")
					stringbuffer_write(b, "            },\n")
					key = ds_map_find_next(tile_data, key)
				}
				stringbuffer_write(b, "        }\n")
				stringbuffer_write(b, "    },\n")
		#endregion
		}
		stringbuffer_write(b, "}\n")
		stringbuffer_write(b, "\n")
#endregion

#region collision data
		stringbuffer_write(b, "local STAGE_COLLISION = {\n")
		for (var i = 0; i < global.collision_type_num; i++) {
			var obj = global.collision_types[i, CollisionType.object]
			var count = instance_number(obj)
			if (count > 0) {
				var ror_name = global.collision_types[i, CollisionType.rorObject]
				stringbuffer_write(b, "    [\"" + ror_name + "\"] = {\n")
				stringbuffer_write(b, "        ")
				var obj_count = 0
				with (obj) {
					if (obj_count >= 20) {
						stringbuffer_write(b, "\n        ")
						obj_count = 0
					}
					var _x = (_left << 1) + (x >> 3)
					if (i == Collision.rope) _x += 1
					stringbuffer_write(b, "{" + string(_x) + "," + string((_top << 1) + (y >> 3)) + "}, ")
					obj_count++
				}
				stringbuffer_write(b, "\n")
				stringbuffer_write(b, "    },\n")
			}
		}
		stringbuffer_write(b, "}\n")
		stringbuffer_write(b, "\n")
#endregion

#region objects
		stringbuffer_write(b, "local STAGE_OBJECTS = {\n")
		// create a list sorted by object, to simplify lua code
		var objmap_list = []
		with (objMapObject) {
			// get object name
			var objmap_name = global.ProvEdit_object[obj_id, PROVEDIT_LEVELOBJECT.objName]
			// get object mod
			var objmap_mod = global.ProvEdit_object[obj_id, PROVEDIT_LEVELOBJECT.modName]
			// find current object's entry
			var found_objmap_list = -1
			for (var i = 0; i < array_length_1d(objmap_list); i++) {
				var objmap_details = objmap_list[i]
				if (objmap_details[0] == objmap_name && objmap_details[1] == objmap_mod) {
					found_objmap_list = i
					break
				}
			}
			// if current object hasn't been put in list yet, do it now
			if (found_objmap_list < 0) {
				var list_len = array_length_1d(objmap_list)
				objmap_list[@ list_len] = [objmap_name, objmap_mod, []]
				found_objmap_list = list_len
			}
			// add coords and variable map to current object's list
			var current_obj_list = objmap_list[found_objmap_list]
			var obj_params_list = current_obj_list[2]
			var list_len = array_length_1d(obj_params_list)
			obj_params_list[@ list_len] = [string((_left << 1) + (x >> 3)), string((_top << 1) + (y >> 3)), variables]
		}
		// iterate through ordered list
		for (var i = 0; i < array_length_1d(objmap_list); i++) {
			var objmap_details = objmap_list[i]
			stringbuffer_write(b, "    {\n")
			stringbuffer_write(b, "        \"" + objmap_details[0]
				+ "\", \"" + objmap_details[1] + "\",\n")
			stringbuffer_write(b, "        {\n")
			stringbuffer_write(b, "            ")
			var objmap_params = objmap_details[2]
			var obj_count = 0
			for (var j = 0; j < array_length_1d(objmap_params); j++) {
				if (obj_count >= 20) {
					stringbuffer_write(b, "\n            ")
					obj_count = 0
				}
				var params = objmap_params[j]
				stringbuffer_write(b, "{" + params[0] + "," + params[1] + "," + "{")
				var params_vars = params[2]
				for (var k = ds_map_find_first(params_vars); !is_undefined(k); k = ds_map_find_next(params_vars, k)) {
					var var_val = params_vars[? k]
					stringbuffer_write(b, "[\"" + k + "\"]=" + (is_string(var_val) ? ("\"" + var_val + "\"") : string(var_val)) + ",")
				}
				stringbuffer_write(b, "}}, ")
				obj_count++
			}
			stringbuffer_write(b, "\n        }\n")
			stringbuffer_write(b, "    },\n")
		}
		stringbuffer_write(b, "}\n")
		stringbuffer_write(b, "\n")
#endregion

#region background
		stringbuffer_write(b, "local STAGE_BACKGROUNDS = {\n")
		for (var i = 0; i < array_length_1d(global.level_backgrounds); i++) {
			var currBgObj = global.level_backgrounds[i]
			stringbuffer_write(b, "    [" + string(currBgObj.depth) + "] = {\""
				+ global.ProvEdit_background[currBgObj.background, PROVEDIT_BACKGROUND.resName] + "\", \""
				+ global.ProvEdit_background[currBgObj.background, PROVEDIT_BACKGROUND.modName] + "\", "
				+ string(currBgObj.tilex) + ", "
				+ string(currBgObj.tiley) + ", "
				+ string(currBgObj.parallaxx) + ", "
				+ string(currBgObj.parallaxy) + ", "
				+ string(currBgObj.offsetx) + ", "
				+ string(currBgObj.offsety) + ", "
				+ string(currBgObj.percentx) + ", "
				+ string(currBgObj.percenty) + " },\n")
		}
		stringbuffer_write(b, "}\n")
		stringbuffer_write(b, "\n")
#endregion

#region map object spawns
		stringbuffer_write(b, "local STAGE_INTERACTABLES = {\n")
		for (var i = 0; i < array_length_1d(global.level_map_objects); i++) {
			stringbuffer_write(b, "    {\""
				+ global.ProvEdit_interactable[global.level_map_objects[i], PROVEDIT_INTERACTABLE.objName] + "\", \""
				+ global.ProvEdit_interactable[global.level_map_objects[i], PROVEDIT_INTERACTABLE.modName] + "\"},\n")
		}
		stringbuffer_write(b, "}\n")
		stringbuffer_write(b, "\n")
#endregion

#region enemy spawns
		stringbuffer_write(b, "local STAGE_ENEMIES = {\n")
		for (var i = 0; i < array_length_1d(global.level_enemies); i++) {
			stringbuffer_write(b, "    {\""
				+ global.ProvEdit_enemy[global.level_enemies[i], PROVEDIT_ENEMY.objName] + "\", \""
				+ global.ProvEdit_enemy[global.level_enemies[i], PROVEDIT_ENEMY.modName] + "\"},\n")
		}
		stringbuffer_write(b, "}\n")
#endregion

#region lua code
	stringbuffer_write(b, @'
	-- LEVEL DATA END --
	local function r(t,n,o)local q=_G[t].find(n,o)return q or error("Failed to resolve "..n..":"..o.. " ("..t.."), make sure all resources are loaded before loading the stage.") end

	local function mkObjs()
	    local bg = Object("PELDR_BG")
	    local ts = Object("PELDR_TS")
		local c = camera
		local x,y,w,h=0,0,0,0
	    callback("onCameraUpdate", function() if bg:find(1) or ts:find(1) then x,y,w,h=camera.x,camera.y,camera.width,camera.height end end, -100)
	    local z = {}
	    callback("globalRoomEnd", function(r)
	        for k, _ in pairs(z) do
	            if Surface.isValid(k) then
	                k:free()
	            end
	        end
	    end, -100)
    
	    local di,st,rst = graphics.drawImage,graphics.setTarget,graphics.resetTarget
	    local function chnk(s, ts, x, y, o)
	        local r = {0, 0, 16, 16}
	        local d = {image = s, x = 0, y = 0, region = r}
	        local sf = Surface(512, 512)
			sf:clear()
	        st(sf)
	        local w
	        for _x = x / 16, (x + 512) / 16 do
	            local q = ts[_x]
	            if q ~= nil then
	                for _y = y / 16, (y + 512) / 16 do
	                    local t = q[_y]
	                    if t ~= nil then
	                        r[1] = t[1] * 16 + (o or (t[1] + 1))
	                        r[2] = t[2] * 16 + (o or (t[2] + 1))
	                        d.x = _x * 16 - x
	                        d.y = _y * 16 - y
	                        w = 1
	                        di(d)
	                    end
	                end
	            end
	        end
	        rst()
	        if not w then
	            sf:free()
	            return 0
	        else
	            z[sf] = 1
	            return sf
	        end
	    end
	    local mf,mc = math.floor, math.ceil
	    local vld = Surface.isValid
		ts:addCallback("draw", function(i)
			local d=i:getModData("PELDR")
	        local c = d.c
	        for X = mf(x / 512), mc((x + w) / 512) do
	            local q = c[X]
	            if q == nil then
	                q = {}
	                c[X] = {}
	            end
	            for Y = mf(y / 512), mc((y + h) / 512) do
	                local cc = q[Y]
	                if cc ~= 0 and not vld(cc) then
	                    if cc ~= nil then
	                        z[cc] = nil
	                    end
	                    cc = chnk(d.s, d.t, X * 512, Y * 512,d.g and 1 or 0)
	                    q[Y] = cc
	                end
	                if cc ~= 0 then
	                    cc:draw(X * 512, Y * 512)
	                end
	            end
	        end
		end)
    
		bg:addCallback("draw", function(i)
			local d=i:getModData("PELDR")
			local s=d.s
		
			local fx,fy=d.x+x*d.px+w*d.xo,d.y+y*d.py+h*d.yo

			local sw,x1,x2=1,fx,fx
			if d.hr then
				sw = s.width
				x1 = x1 % sw + x - x % sw - sw
				x2 = x + w
			end

			local sh,y1,y2=1,fy,fy
			if d.vr then
				sh=s.height
				y1 = y1 % sh + y - y % sh - sh
				y2=y + h
			end

			for X=x1,x2,sw do for Y=y1,y2,sh do s:draw(X,Y)end end
		end)
		return ts,bg
	end
	local ts,bg=Object.find("PELDR_TS"),Object.find("PELDR_BG")
	if ts == nil then ts,bg=mkObjs()end

	local function spawnBG(sprite, depth, x, y, hrepeat, vrepeat, xparallax, yparallax, xpercentoffs, ypercentoffs)
		local i=bg:create(0,0)
		d=i:getModData("PELDR")
		i.depth = depth
		d.s = sprite
		d.x = x
		d.y = y
		d.hr = hrepeat
		d.vr = vrepeat
		d.px = xparallax
		d.py = yparallax
		d.xo = xpercentoffs
		d.yo = ypercentoffs
	end

	local function spawnTS(sprite, depth, tiles, grid)
		local i=ts:create(0,0)
		d=i:getModData("PELDR")
	    i.depth = depth
	    d.c = {}
	    d.s = sprite
	    d.g = grid
	    d.t = tiles
	end

	local room = Room.new(STAGE_INFO.name)
	room:resize(STAGE_INFO.width, STAGE_INFO.height)
	for col, coordlist in pairs(STAGE_COLLISION) do
		local obj = Object.find(col, "Vanilla")
		for _, coords in ipairs(coordlist) do
	        room:createInstance(obj, coords[1]*8, coords[2]*8)
	    end
	end
	for _, objectlist in ipairs(STAGE_OBJECTS) do
		local obj = r("Object", objectlist[1], objectlist[2])
		for _, params in ipairs(objectlist[3]) do
			params[4] = room:createInstance(obj, params[1]*8, params[2]*8)
		end
	end
	local function popvars()
	    for _, objectlist in ipairs(STAGE_OBJECTS) do
	        for _, params in ipairs(objectlist[3]) do
	            local inst = Object.findInstance(params[4])
	            if inst then
	                local acs = inst:getAccessor()
	                for vk, vv in pairs(params[3]) do
	                    acs[vk] = vv
	                end
	            end
	        end
	    end
	end

	local stage = Stage.new(STAGE_INFO.name)
	stage.subname = STAGE_INFO.subname
	stage.rooms:add(room)
	stage.music = Sound.find(STAGE_INFO.music) or Sound.find("MusicStage1")

	for _, i in ipairs(STAGE_INTERACTABLES) do
	    stage.interactables:add(r("Interactable", i[1], i[2]))
	end
	for _, e in ipairs(STAGE_ENEMIES) do
	    stage.enemies:add(r("MonsterCard", e[1], e[2]))
	end

	local bgs = {}
	for k, v in pairs(STAGE_BACKGROUNDS) do
	    table.insert(bgs, {r("Sprite", v[1], v[2]), k, v[7], v[8], v[3]==1, v[4]==1, v[5], v[6], v[9], v[10]})
	end
	local lrs = {}
	for _, v in ipairs(STAGE_LAYERS) do
	    table.insert(lrs, {r("Sprite", v.sprite, v.origin), v.depth, v.tiles, v.grid})
	end
	local function mrgcol(o)
	    for _, v in ipairs(o:findAll()) do
	        v.xscale = 1 / 16
	    end
	    local c
	    repeat
	        c = 0
	        for _, v in ipairs(o:findAll()) do
	            if v:isValid() and v.xscale < 1 then
	                local s = o:findPoint(v:get("bbox_right") + 16, v.y)
	                if s and s.xscale < 1 then
	                    c = 1
	                    v.xscale = v.xscale + s.xscale
	                    s:destroy()
	                end
	            end
	        end
	    until c == 0
	end
	local bs = Object.find("bossSpawn","vanilla")
	local bs2 = Object.find("bossSpawn2","vanilla")
	callback("globalRoomStart", function(r)
	    if r == room then
	        for _, v in ipairs(bgs) do
	            spawnBG(table.unpack(v))
	        end
	        for _, v in ipairs(lrs) do
	            spawnTS(table.unpack(v))
	        end
	        mrgcol(bs)
	        mrgcol(bs2)
	        popvars()
	    end
	end)


	return stage')
#endregion

	var b2 = buffer_create(buffer_tell(b), buffer_fixed, 1)
	buffer_copy(b, 0, buffer_tell(b), b2, 0)
	buffer_delete(b)

	return b2




}
